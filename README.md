# Thoughts on federated entity

Проект предназначен для централизованного хранения сущности, за различные части которой отвечают разные системы

* Предполагаются две схемы доступа: нагруженная на чтение и запись в рамках конкретной сущности и не нагруженный административный доступ

* Предполагаются три хранилища: основное надёжное, кеширующее и поисковое/аналитическое, для административного доступа.

* В кеширующее пишем сагами сразу на месте, в поисковое/аналитическое пишем с отставанием, чтобы не задерживать ожиданием нагруженную часть

Провайдеры
" Данные поставляются провайдерами по апи
* У каждого провайдера свои данные для доступа к системе
* Мы исходим из того что мы не знаем есть ли у сущности какие-то данные провайдеров или нет, мы не можем рассчитывать на их наличие
* Провайдер при запросе может определить, данные каких провайдеров ему нужны
* Администратор определяет, каким провайдерам какие другие провайдеры доступны 
* Администратор определяет версии данных провайдеров и их схему данных. При записи или чтении указывается версия, чтобы можно было понять/провалидировать данные
* Администратором определяются composed сущности, которые собираются на основе данных провайдеров, схема этих сущностей тоже версионируется, доступ для провайдеров определяется либо целиком к подобной сущности, либо с точностью до поля сущности
* Реилизуется методы для административного интерфейса для просмотра как сущность будет выглядеть для конкретного оператора с теми или иными настройками

* Для проекта разрабатывается пакет интеграционного тестирования, который позволит проверить любую реализацию на соответствие спецификации
* Для проекта выделяются ключевые сценарии, для которых разрабатывается нагрузочное тестирование

* Нам нужны операции восстановления данных кеша, если они были утеряны или восстановлены из бекапа с отставанием, восстановления аналитической базы

* Если по сущности у нас становятся доступными сразу несколько версий данных какого-то провайдера или composed сущности - оставляем последнюю
* В системе нет проверок уникальности по каким-то полям между сущностями 
* если от оператора пришло сообщена за запись данных по сущности, а ее ещё нет - она создается
* Корневая сущность - это просто идентификатор + прикреплённые данные операторов + вычисленные composed сущности

* Предположим что у нас 150 миллионов пользователей, к нам обращаются 10 систем, у всех пользователей есть аккаунты во всех 10 системах, они ходят в каждую из систем дважды в день, для этого по ним раз читаются данные и один раз пишутся (ТК они что-то совершили в системе). Это даёт около 100 обращений на чтение и столько же на запись в секунду при равномерном распределении. Если предположить вся нагрузка приходится только на половину суток и самый нагруженный час обрабатывает в 3 раза больше запросов чем средний то это получается около 600 запросов на чтение и столько же на запись в секунду
* Предположим для в качестве данных система посылает нам  Json из 30 полей, 10 строк, 10 чисел, 5 флагов и 5 массивов строк с 5 элементами
* При отправке на запись система прикрепляет к сообщению ключ дедубликация, чтобы мы отличали один ее запрос от другого и не пытались дважды обработать перепосланное сообщение
* Система не считает что сообщение доставлено пока мы не сообщим ей об успехе

* В административную часть есть доступ у администраторов операторов
